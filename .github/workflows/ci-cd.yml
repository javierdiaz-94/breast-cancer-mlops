# Nombre del flujo de trabajo que se mostrará en la pestaña "Actions" de GitHub.
name: CI/CD Pipeline

# Define los eventos que activarán la ejecución de este flujo de trabajo.
on:
  # Se activa cuando se hace un push a las ramas main o develop.
  push:
    branches:
      - main
      - develop
  # Se activa cuando se crea o actualiza un pull request dirigido a las ramas main o develop.
  pull_request:
    branches:
      - main
      - develop

# Define los trabajos (jobs) que se ejecutarán como parte del flujo de trabajo.
jobs:
  # Primer trabajo: "test". Su propósito es ejecutar las pruebas unitarias.
  test:
    name: Run Tests
    # El tipo de máquina virtual en la que se ejecutará el trabajo.
    runs-on: ubuntu-latest

    steps:
      # Paso 1: Descarga el código del repositorio a la máquina virtual.
      - name: Checkout code
        uses: actions/checkout@v3

      # Paso 2: Configura el entorno de Python en la versión especificada.
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      # Paso 3: Configura la caché para las dependencias de pip.
      # Esto acelera las futuras ejecuciones al reutilizar las dependencias descargadas.
      - name: Cache dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # Paso 4: Instala las dependencias del proyecto listadas en requirements.txt.
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # Paso 5: Ejecuta el script de entrenamiento del modelo.
      - name: Train model
        run: |
          python models/train_model.py

      # Paso 6: Ejecuta las pruebas unitarias con pytest y genera un informe de cobertura.
      - name: Run unit tests
        run: |
          pytest tests/ -v --cov=api --cov-report=term-missing

      # Paso 7: Sube el informe de cobertura de código a Codecov.
      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        if: always() # Se ejecuta siempre, incluso si los pasos anteriores fallan.

  # Segundo trabajo: "build". Su propósito es construir la imagen de Docker.
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    # Este trabajo depende de que el trabajo "test" se complete con éxito.
    needs: test

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Train model for Docker
        run: |
          python models/train_model.py

      # Paso 5: Configura Docker Buildx, una herramienta para construir imágenes avanzadas.
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      # Paso 6: Construye la imagen de Docker y la etiqueta con el SHA del commit y como "latest".
      - name: Build Docker image
        run: |
          docker build -t breast-cancer-api:${{ github.sha }} .
          docker tag breast-cancer-api:${{ github.sha }} breast-cancer-api:latest

      # Paso 7: Realiza una prueba rápida para verificar que la imagen de Docker funciona.
      - name: Test Docker image
        run: |
          docker run -d -p 5000:5000 --name test-api breast-cancer-api:latest
          sleep 10
          curl -f http://localhost:5000/ || exit 1
          docker stop test-api
          docker rm test-api

      # Paso 8: Inicia sesión en Docker Hub. Se ejecuta solo en pushes a la rama "main".
      - name: Log in to Docker Hub (optional)
        if: github.ref == 'refs/heads/main'
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      # Paso 9: Sube la imagen a Docker Hub. Se ejecuta solo en pushes a la rama "main".
      - name: Push to Docker Hub (optional)
        if: github.ref == 'refs/heads/main'
        run: |
          docker tag breast-cancer-api:latest ${{ secrets.DOCKER_USERNAME }}/breast-cancer-api:latest
          docker tag breast-cancer-api:latest ${{ secrets.DOCKER_USERNAME }}/breast-cancer-api:${{ github.sha }}
          docker push ${{ secrets.DOCKER_USERNAME }}/breast-cancer-api:latest
          docker push ${{ secrets.DOCKER_USERNAME }}/breast-cancer-api:${{ github.sha }}

  # Tercer trabajo: "integration-test". Ejecuta pruebas de integración contra el contenedor Docker.
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Train model
        run: |
          python models/train_model.py

      - name: Build Docker image
        run: |
          docker build -t breast-cancer-api:test .

      # Paso 6: Ejecuta el contenedor Docker en segundo plano para las pruebas.
      - name: Run container
        run: |
          docker run -d -p 5000:5000 --name integration-test breast-cancer-api:test
          sleep 15

      # Paso 7: Ejecuta un script de Python en línea para probar los endpoints de la API.
      - name: Run integration tests
        run: |
          python -c "
          import requests
          import json

          # Prueba el endpoint de estado del servicio
          print('Testing health check endpoint...')
          response = requests.get('http://localhost:5000/')
          assert response.status_code == 200, 'Health check failed'
          print('Health check: OK')

          # Prueba el endpoint de predicción
          print('Testing prediction endpoint...')
          payload = {
              'mean_radius': 17.99, 'mean_texture': 10.38, 'mean_perimeter': 122.8,
              'mean_area': 1001.0, 'mean_smoothness': 0.1184, 'mean_compactness': 0.2776,
              'mean_concavity': 0.3001, 'mean_concave_points': 0.1471, 'mean_symmetry': 0.2419,
              'mean_fractal_dimension': 0.07871, 'radius_error': 1.095, 'texture_error': 0.9053,
              'perimeter_error': 8.589, 'area_error': 153.4, 'smoothness_error': 0.006399,
              'compactness_error': 0.04904, 'concavity_error': 0.05373, 'concave_points_error': 0.01587,
              'symmetry_error': 0.03003, 'fractal_dimension_error': 0.006193, 'worst_radius': 25.38,
              'worst_texture': 17.33, 'worst_perimeter': 184.6, 'worst_area': 2019.0,
              'worst_smoothness': 0.1622, 'worst_compactness': 0.6656, 'worst_concavity': 0.7119,
              'worst_concave_points': 0.2654, 'worst_symmetry': 0.4601, 'worst_fractal_dimension': 0.1189
          }
          response = requests.post(
              'http://localhost:5000/predict',
              json=payload,
              headers={'Content-Type': 'application/json'}
          )
          assert response.status_code == 200, f'Prediction failed with status {response.status_code}'
          result = response.json()
          assert 'prediction' in result, 'Missing prediction in response'
          assert 'confidence' in result, 'Missing confidence in response'
          print('Prediction test: OK')
          print(f'Result: {result}')
          "

      # Paso 8: Detiene y elimina el contenedor de prueba para limpiar el entorno.
      - name: Stop and remove container
        if: always()
        run: |
          docker stop integration-test || true
          docker rm integration-test || true